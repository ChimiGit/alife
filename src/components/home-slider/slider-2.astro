---
---

<div class="fixed inset-0 w-full h-full overflow-hidden bg-[#ffb5a7]" style="font-family: 'Inter', sans-serif; position: fixed !important; width: 100vw !important; height: 100vh !important; min-height: 100vh !important;">
  <!-- Particle Animation Canvas -->
  <canvas id="designCanvas" class="absolute inset-0 w-full h-full z-5" style="touch-action: none; background-color: transparent; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;"></canvas>

    <!-- Text Content -->
    <section class="absolute bottom-20 md:bottom-16 left-0 right-0 mb-8 sm:mb-10 px-4 sm:px-6 z-[60] hero-section-spacing mt-8 md:mt-0">
      <div class="max-w-6xl mx-auto px-4 sm:px-6">
        <h1
        class="text-6xl sm:text-64px md:text-64px lg:text-[96px] text-primary mt-10 md:mt-0"
        style={`font-family: ${
          "'GT Alpina Fine', serif"
        }; margin: 0; line-height: 90%;  letter-spacing: -0.3%;`}
      >
      Exploring Symbiosis
      </h1>
      <h1
      class="text-6xl sm:text-6xl md:text-64px lg:text-[96px] text-primary"
      style={`font-family: ${
        "'GT Alpina Fine', serif"
      }; margin: 0; line-height: 90%;  letter-spacing: -0.3%;`}
    >
      <span class="md:hidden">Between</span>
      <span class="hidden md:inline">Between All Forms of</span>
    </h1>
      <h1
      class="text-6xl sm:text-6xl md:text-64px lg:text-[96px] text-primary"
      style={`font-family: ${
        "'GT Alpina Fine'"
      }; margin: 0; line-height: 90%; letter-spacing: -0.3%;`}
    >
    <span class="md:hidden">All Forms of Intelligence</span>
    <span class="hidden md:inline">Intelligence</span>
    </h1>
    <p
    class="text-primary max-w-xs sm:max-w-md md:max-w-xl lg:max-w-2xl font-light mt-6 sm:mt-8 lg:mt-10 text-base md:text-lg"
    style={`font-family: ${
      "'Inter', sans-serif"
    }; line-height: 150%;`}
    >
    We’re cultivating alternative pathways to intelligence through evolution itself—creating systems that don’t just optimize, but discover, surprise, and continuously evolve, just like the nature. This is where we pave a way for a future not engineered, but grown organically through bottom-up approaches where humans and artificial life forms collaborate toward digital democracy and a more diverse AI ecosystem.</p>
      </div>
    </section>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Set up the canvas
    const canvas = document.getElementById('designCanvas');
    const ctx = canvas.getContext('2d');
    
    if (!ctx || !canvas) return; // Exit if canvas context is not available
    
    // --- Configuration ---
    let currentCanvasWidth = 0;
    let currentCanvasHeight = 0;

    const RECTANGLE_WIDTH = 300;
    const RECTANGLE_HEIGHT = 150;
    const SHEAR_X = -0.5;
    const PARTICLE_SIZE = 3; // Increased from 2 to 3 (50% larger)
    const DAMPING = 1.0;
    const INITIAL_SPEED = 0.15; // Increased from 0.1 to 0.15 (50% faster)
    const SCROLL_SPEED = 0.7; // Increased from 0.5 to 0.7 (40% faster)

    const SOLID_COLOR = "#FFB5A7";
    const PARTICLE_COLOR_RGBA = "rgba(100, 150, 200, 0.9)";

    const PARTICLE_COUNT_PER_RECTANGLE = 1000;
    const GRADIENT_DENSITY_FACTOR_Y = 2;

    const CENTER_GAP = 150;
    const CLIP_OFFSET_LEFT = 200; // Shift clipping left to show more on the left side 

    let allParticles = [];
    let allCells = [];
    let gridTotalHeight = 0;
    let numRows = 0;
    let numCols = 0;
    let effectiveCellHeight = 0;
    let X_START_GLOBAL = 0; // used for exact wrap positioning

    // --- Setup and Initialization ---

    function resizeCanvas() {
      if (!ctx || !canvas) return;
      
      const dpr = window.devicePixelRatio || 1;
      currentCanvasWidth = window.innerWidth;
      currentCanvasHeight = window.innerHeight;
      
      canvas.width = currentCanvasWidth * dpr;
      canvas.height = currentCanvasHeight * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = `${currentCanvasWidth}px`;
      canvas.style.height = `${currentCanvasHeight}px`;

      initializeCellsAndParticles();

      if (!window.animationFrameId) {
        animate();
      }
    }

    function initializeCellsAndParticles() {
      allCells = [];
      allParticles = [];

      const effectiveCellWidth = RECTANGLE_WIDTH;
      effectiveCellHeight = RECTANGLE_HEIGHT;

      const X_MIDPOINT = currentCanvasWidth / 2;
      const LEFTWARD_EXTENSION = Math.abs(SHEAR_X * RECTANGLE_HEIGHT);

      // Start a bit further to the right
      const X_START = X_MIDPOINT + LEFTWARD_EXTENSION + CENTER_GAP;
      X_START_GLOBAL = X_START;

      const displayWidthToCover = currentCanvasWidth - X_START;
      numCols = Math.ceil(displayWidthToCover / effectiveCellWidth) + 2;
      
      // Calculate minimum rows needed to cover screen + 1 extra row for seamless wrap
      numRows = Math.ceil(currentCanvasHeight / effectiveCellHeight) + 1;
      gridTotalHeight = numRows * effectiveCellHeight;

      let particleId = 0;
      const INIT_MARGIN = 1;
      const effectiveW = RECTANGLE_WIDTH - 2 * INIT_MARGIN;
      const effectiveH = RECTANGLE_HEIGHT - 2 * INIT_MARGIN;

      // Start row iteration from 0 to minimize initial overlap, relying on the loop's size and wrap logic
      for (let row = 0; row < numRows; row++) {
        const rowShiftX = row * SHEAR_X * RECTANGLE_HEIGHT;

        for (let col = 0; col < numCols; col++) {
          const cellX = X_START + col * effectiveCellWidth + rowShiftX;
          const cellY = row * effectiveCellHeight;

          // Alternating pattern by row parity to avoid double-rectangle alignment
          const isEvenRow = row % 2 === 0;
          const isParticleCell = isEvenRow ? (col % 2 !== 0) : (col % 2 === 0);

          const cell = {
            x: cellX,
            y: cellY,
            width: RECTANGLE_WIDTH,
            height: RECTANGLE_HEIGHT,
            shear: SHEAR_X,
            isParticle: isParticleCell,
            particles: [],
            originalRow: row,
            originalCol: col,
          };
          allCells.push(cell);

          if (isParticleCell) {
            for (let i = 0; i < PARTICLE_COUNT_PER_RECTANGLE; i++) {
              let randX = Math.random();
              let localX = randX * effectiveW + INIT_MARGIN;
              let randY = Math.random();
              let biasedY = Math.pow(randY, GRADIENT_DENSITY_FACTOR_Y);
              let localY = biasedY * effectiveH + INIT_MARGIN;

              let transformedXLocal = localX + SHEAR_X * localY;
              let transformedX = cellX + transformedXLocal;
              let transformedY = cellY + localY;

              const angle = Math.random() * Math.PI * 2;
              const speed = (Math.random() * 0.5 + 0.5) * INITIAL_SPEED;

              const particle = {
                x: transformedX,
                y: transformedY,
                localX,
                localY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                parentCell: cell,
                id: particleId++,
              };
              allParticles.push(particle);
              cell.particles.push(particle);
            }
          }
        }
      }
    }

    // --- Core Animation Logic ---

    function updateCells() {
      const yShift = SCROLL_SPEED;
      const xShiftDueToShear = yShift * SHEAR_X;

      allParticles.forEach((p) => {
        p.y += yShift;
      });

      allCells.forEach((cell) => {
        cell.y += yShift;
        cell.x += xShiftDueToShear;

        // When the bottom of the cell passes the bottom of the screen
        if (cell.y > currentCanvasHeight) { 
          // Move up exactly one grid cycle to maintain seamless wrapping
          cell.y -= gridTotalHeight;
          cell.x -= numRows * SHEAR_X * RECTANGLE_HEIGHT;

          if (cell.isParticle) {
            cell.particles.forEach((p) => {
              p.y = cell.y + p.localY;
              p.x = cell.x + p.localX + cell.shear * p.localY;
            });
          }
        }
      });
    }

    function updateParticles() {
      const perturbation = 0.1;

      allParticles.forEach((p) => {
        const cell = p.parentCell;
        const W = cell.width;
        const H = cell.height;

        p.vx *= DAMPING;
        p.vy *= DAMPING;
        p.localX += p.vx;
        p.localY += p.vy;

        let didCollide = false;

        if (p.localY < 0) {
          p.localY = 0;
          p.vy = -p.vy + Math.random() * perturbation;
          didCollide = true;
        } else if (p.localY + PARTICLE_SIZE > H) {
          p.localY = H - PARTICLE_SIZE;
          p.vy = -p.vy - Math.random() * perturbation;
          didCollide = true;
        }

        if (p.localX < 0) {
          p.localX = 0;
          p.vx = -p.vx + Math.random() * perturbation;
          didCollide = true;
        } else if (p.localX + PARTICLE_SIZE > W) {
          p.localX = W - PARTICLE_SIZE;
          p.vx = -p.vx - Math.random() * perturbation;
          didCollide = true;
        }

        if (didCollide) {
          p.vy += (Math.random() - 0.5) * perturbation * 2;
        }

        p.x = cell.x + p.localX + cell.shear * p.localY;
        p.y = cell.y + p.localY;
      });
    }

    function drawDesign() {
      if (!ctx) return;
      
      ctx.clearRect(0, 0, currentCanvasWidth, currentCanvasHeight);

      const X_MIDPOINT = currentCanvasWidth / 2;
      const X_CLIP_START = X_MIDPOINT - CLIP_OFFSET_LEFT;

      ctx.save();
      ctx.beginPath();
      ctx.rect(X_CLIP_START, 0, currentCanvasWidth - X_CLIP_START, currentCanvasHeight);
      ctx.clip();

      allCells.forEach((cell) => {
        if (!cell.isParticle) {
          // Skip cells that are off-screen to optimize rendering
          const cellRight = cell.x + cell.width + Math.abs(cell.shear * cell.height);
          const cellLeft = cell.x + cell.shear * cell.height;
          if (cellRight < X_CLIP_START || cellLeft > currentCanvasWidth) {
            return;
          }
          drawCellRectangle(cell.x, cell.y, cell.width, cell.height, cell.shear, SOLID_COLOR);
        }
      });

      ctx.fillStyle = PARTICLE_COLOR_RGBA;
      const particleRadius = PARTICLE_SIZE / 2;
      allParticles.forEach((p) => {
        // Expanded bounds check to account for particle radius - ensures full visibility when zoomed
        if (p.x >= X_CLIP_START - particleRadius && p.x < currentCanvasWidth + particleRadius && p.y > -particleRadius && p.y < currentCanvasHeight + particleRadius) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, particleRadius, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      ctx.restore();
    }

    function drawCellRectangle(x, y, width, height, shearX, fillColor) {
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + width, y);
      ctx.lineTo(x + width + shearX * height, y + height);
      ctx.lineTo(x + shearX * height, y + height);
      ctx.closePath();
      ctx.fillStyle = fillColor;
      ctx.fill();
    }

    // --- Main Animation Loop ---

    function animate() {
      if (!ctx) return;
      
      updateCells();
      updateParticles();
      drawDesign();
      
      // Pause animation when page is hidden to save resources
      if (!document.hidden) {
        window.animationFrameId = requestAnimationFrame(animate);
      }
    }

    // Resume animation when page becomes visible
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && !window.animationFrameId) {
        animate();
      }
    });

    // Listen for window resize to make the canvas responsive
    window.addEventListener('resize', resizeCanvas);

    // Initial setup
    resizeCanvas();
  });
</script>
